/*Connect to Mesh - Fixes a Locator to a Mesh based off two adjacent non-consecutive edgesThis script is designed to reduce the number of steps involved in properly riveting a locatorto a polygon object. If you are using a nurbs object, please use a surface constraint.The steps involve1) creating the loft2) connecting it a point on surface info node3) creating a locator under a transform driven by the pointOnSurfaceInfo4) normal constraining it for proper orientation5) locking attributes to prevent offsetVersion: 1.0.0Site: http://www.digitaltutors.comDisclaimer: Code distributed as is*/global proc CTM(){   headsUpMessage "Reminder: make sure you have two non-consecutive edges selected";   string $sel[];   $sel = `ls -sl`; //Get selection   int $i = $i+1; //Set increment counter   string $CTM_loft = "CTM_loft_transform" + $i;   //Store loft created objects   string $CTM_names[] = `loft -n $CTM_loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true $sel[0] $sel[1]`;   $CTM_loft = $CTM_names[1];                        //Loft Node name   $CTM_loft_node = `rename $CTM_loft ("CTM_loft" + $i)`;        //Loft Node renamed   string $CTM_ps = "CTM_ps" + $i;                    //Point on Surface (POSI) name   $CTM_ps = `createNode -n $CTM_ps pointOnSurfaceInfo`;        //Create POSI node with designated name   setAttr ($CTM_ps + ".turnOnPercentage") 1;   //Set the loft surface as the input surface of the POSI node   connectAttr ($CTM_loft_node + ".outputSurface") ($CTM_ps + ".inputSurface");   string $CTM_con = `group -n CTM_connected -em`;            //Create transform   string $CTM_loc_node[] = `spaceLocator -n "CTM_loc"`;        //Make locator   string    $CTM_loc = `rename $CTM_loc_node ("CTM_loc" + $i)`;    //Rename to derive unique name   parent $CTM_loc $CTM_con;                        //Parent locator     //Tie the transform to the POSI position   connectAttr ($CTM_ps + ".position") ($CTM_con + ".translate");   setAttr ($CTM_loft_node + ".close") 1;   //Reuse variable $CTM_loft but this time, get the transform node of the lofted surface   $CTM_loft = $CTM_names[0];   //Create normal constraint for proper orientation   select ($CTM_loft + ".cv[1][0:3]"); select -add $CTM_con ;   string $CTM_normName[] = `normalConstraint -n ("$CTM_norm" + $i) -w 1 -aim 1 0 0 -u 0 1 0 -wut "vector" -wu 0 1 0`;   string $CTM_norm = $CTM_normName[0];   $CTM_norm = `rename $CTM_norm ("CTM_norm" + $i)`;   connectAttr ($CTM_ps + ".tangentU") ($CTM_norm + ".worldUpVector") ;   connectAttr -f ($CTM_loft_node + ".outputSurface") ($CTM_norm + ".target[0].targetGeometry");   //remove loft transform   delete $CTM_loft;   //Lock transform to prevent offset   setAttr -lock true -keyable false ($CTM_con + ".tx");   setAttr -lock true -keyable false ($CTM_con + ".ty");   setAttr -lock true -keyable false ($CTM_con + ".tz");   setAttr -lock true -keyable false ($CTM_con + ".rx");   setAttr -lock true -keyable false ($CTM_con + ".ry");   setAttr -lock true -keyable false ($CTM_con + ".rz");   setAttr -lock true -keyable false ($CTM_con + ".sx");   setAttr -lock true -keyable false ($CTM_con + ".sy");   setAttr -lock true -keyable false ($CTM_con + ".sz");   setAttr -lock true -keyable false ($CTM_con + ".v");   //Clear selection   select -cl;};